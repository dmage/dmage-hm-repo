#!/bin/false
# vim: set ts=4 sts=4 sw=4 noet :
set -euo pipefail


LOCAL_RSYNC="rsync"
REMOTE_RSYNC="rsync -e ssh"


color() {
	if [ -n "$TERM" ]; then
		tput -T "$TERM" "$@" || true
	fi
}

COLOR_BOLD=$(color bold)
COLOR_RED=$(color setaf 1)
COLOR_GREEN=$(color setaf 2)
COLOR_BLUE=$(color setaf 4)
COLOR_YELLOW=$(color setaf 3)
COLOR_RESET=$(color sgr0)

pkgname() {
	echo "$COLOR_BOLD$COLOR_GREEN$*$COLOR_RESET"
}

prefix() {
	echo "$COLOR_BOLD$COLOR_YELLOW$*$COLOR_RESET"
}

alert() {
	echo "$COLOR_BOLD$COLOR_BLUE$*$COLOR_RESET"
}


set_size() {
	local __SET_NAME=$1
	local __REF="$__SET_NAME[@]"
	if [ "x${!__REF+set}" = "xset" ]; then
		local -a __SET_DATA=("${!__REF}")
		echo "${#__SET_DATA[@]}"
	else
		echo 0
	fi
}

set_add() {
	local __SET_NAME=$1
	local __VALUE=$2
	local __REF="$__SET_NAME[@]"
	if [ "x${!__REF+set}" = "xset" ]; then
		local -a __SET_DATA=("${!__REF}")

		for i in "${__SET_DATA[@]}"; do
			if [ "x$i" = "x$__VALUE" ]; then
				return 0
			fi
		done

		unset -v "$__SET_NAME"
		eval "$__SET_NAME=(\"\${__SET_DATA[@]}\" \"\$__VALUE\")"
	else
		unset -v "$__SET_NAME"
		eval "$__SET_NAME=(\"\$__VALUE\")"
	fi
}

set_have() {
	local __SET_NAME=$1
	local __VALUE=$2
	local __REF="$__SET_NAME[@]"
	if [ "x${!__REF+set}" = "xset" ]; then
		local -a __SET_DATA=("${!__REF}")

		for i in "${__SET_DATA[@]}"; do
			if [ "x$i" = "x$__VALUE" ]; then
				echo "1"
				return 0
			fi
		done

		echo "0"
	else
		echo "0"
	fi
}


fake_init() {
	FAKE_TMP_DIR=$(mktemp -d -t hm-make.XXXXXXXXXX)
	FAKE_ROOT="${FAKE_TMP_DIR}/root"
	FAKE_INDEX="${FAKE_TMP_DIR}/index"
	FAKE_FILES_DIR="${FAKE_TMP_DIR}/files"

	rm -rf "$FAKE_FILES_DIR" && mkdir -p "$FAKE_FILES_DIR"
	rm -rf "$FAKE_ROOT" && mkdir -p "$FAKE_ROOT"
	rm -f "$FAKE_INDEX"
}

fake_cleanup() {
	rm -rf "$FAKE_FILES_DIR"
	rm -rf "$FAKE_ROOT"
	rm -f "$FAKE_INDEX"
	rmdir "$FAKE_TMP_DIR"
}


schedule_init() {
	declare -g SCHEDULE_PKGS=()
}

__schedule_pkg() {
	local PKG=$(cd $1; pwd -P)

	shift
	local -a LOOP_DETECT=("$@")

	if [ $(set_have LOOP_DETECT "$PKG") -ne 0 ]; then
		echo "$PKG: loop detected" >&2
		echo "Trace:" >&2
		for i in "${LOOP_DETECT[@]}"; do
			echo "	  $i" >&2
		done
		echo "	  $PKG (loop)" >&2
		exit 1
	fi

	if [ -d "$PKG/inherit" ]; then
		for INHERIT_PKG in "$PKG/inherit"/*; do
			__schedule_pkg "$INHERIT_PKG" "$@" "$PKG"
		done
	fi

	set_add SCHEDULE_PKGS "$PKG"
}

schedule_pkg() {
	__schedule_pkg "$1"
}


discover_dump() {
	echo "# generated by discover_dump"
	for DISCOVER_VAR in "${!DISCOVER_@}"; do
		printf '%s=%q\n' "$DISCOVER_VAR" "${!DISCOVER_VAR}"
	done
	echo
}

discover_export() {
	for DISCOVER_VAR in "${!DISCOVER_@}"; do
		export "$DISCOVER_VAR"
	done
}

real_dump() {
	echo "# generated by real_dump"
	for REAL_VAR in "${!REAL_@}"; do
		printf '%s=%q\n' "$REAL_VAR" "${!REAL_VAR}"
	done
	echo
}


self_content() {
	cat "$BASH_SOURCE"
}

real_bash() {
	if [ -n "${REAL_HOST:-}" ]; then
		ssh -T "$REAL_HOST" -l "${REAL_LOGIN:-$(whoami)}" bash
	else
		bash
	fi
}


real_discover() {
	eval "$(
		(
			real_dump
			self_content
			for PKG in "${SCHEDULE_PKGS[@]}"; do
				if [ -r "$PKG/discover" ]; then
					echo "# $PKG/discover"
					cat "$PKG/discover"
					echo
				fi
			done
			cat <<- EOF
				discover_dump
			EOF
		) | real_bash
	)"
	discover_export
}

real_remote() {
	(
		real_dump
		self_content
		discover_dump
		for PKG in "${SCHEDULE_PKGS[@]}"; do
			if [ -r "$PKG/remote" ]; then
				echo "# $PKG/remote"
				cat "$PKG/remote"
				echo
			fi
		done
	) | real_bash
}


install_pkg() {
	local PKG=$(cd $1; pwd -P)

	local REPO=$(cd "$PKG/.."; pwd -P)
	local REPO_NAME=$(basename "$REPO")
	local PKG_NAME=$(basename "$PKG")
	
	echo "$(prefix ">>>") $(pkgname "$REPO_NAME/$PKG_NAME")"

	if [ -x "$PKG/preinst" ]; then
		pushd "$FAKE_ROOT" >/dev/null
		"$PKG/preinst"
		popd >/dev/null
	fi

	local FAKE_WORKDIR="$FAKE_FILES_DIR/$REPO_NAME/$PKG_NAME"
	if [ -x "$PKG/install" ]; then
		mkdir -p "$FAKE_WORKDIR"

		export HM_REAL_ROOT="$REAL_ROOT"
		export HM_LOCAL_RSYNC="$LOCAL_RSYNC"
		export HM_PKG="$PKG"
		export HM_WORKDIR="$FAKE_WORKDIR"
		pushd "$HM_PKG" >/dev/null
		"$PKG/install"
		popd >/dev/null
		unset HM_REAL_ROOT
		unset HM_LOCAL_RSYNC
		unset HM_PKG
		unset HM_WORKDIR

		create_symlinks_for_pkg_files "$REPO_NAME/$PKG_NAME"
	elif [ -d "$PKG/files" ]; then
		mkdir -p "$FAKE_WORKDIR"

		$LOCAL_RSYNC -av "$PKG/files/" "$FAKE_WORKDIR/"

		create_symlinks_for_pkg_files "$REPO_NAME/$PKG_NAME"
	fi

	if [ -x "$PKG/postinst" ]; then
		pushd "$FAKE_ROOT" >/dev/null
		"$PKG/postinst"
		popd >/dev/null
	fi
}

create_symlinks_for_pkg_files() {
	local REPO_AND_PKG_NAME=$1

	while IFS= read -r -d $'\0' file; do
		mkdir -p "$(dirname "$FAKE_ROOT/${file#./}")"
		ln -s "$REAL_FILES_DIR/$REPO_AND_PKG_NAME/${file#./}" "$FAKE_ROOT/${file#./}"
		printf "%s\0" "$REAL_ROOT/${file#./}" >>"$FAKE_INDEX"
	done < <(cd "$FAKE_FILES_DIR/$REPO_AND_PKG_NAME"; find . -not -type d -print0)
}

create_symlinks_for_all_pkg_files() {
	pushd "$FAKE_FILES_DIR" >/dev/null
	REPO_AND_PKG_ARRAY=(*/*)
	popd >/dev/null

	for REPO_AND_PKG_NAME in "${REPO_AND_PKG_ARRAY[@]}"; do
		create_symlinks_for_pkg_files "$REPO_AND_PKG_NAME"
	done
}

fake_install() {
	for PKG in "${SCHEDULE_PKGS[@]}"; do
		install_pkg "$PKG"
	done
}


rsync_real_prefix() {
	if [ -n "${REAL_HOST:-}" ]; then
		if [ -n "${REAL_LOGIN:-}" ]; then
			echo -n "${REAL_LOGIN:-}@"
		fi
		echo "${REAL_HOST:-}:"
	fi
}

rsync_files_dir() {
	echo "$(prefix ">>>") $(alert "merging hm-files into real system ($REAL_FILES_DIR, backup: $REAL_BACKUP_FILES_DIR)")"
	(
		real_dump
		self_content
		cat <<- EOF
			create_backup_files_dir
		EOF
	) | real_bash

	$REMOTE_RSYNC --backup-dir="$REAL_BACKUP_FILES_DIR" --backup -av --delete "$FAKE_FILES_DIR/" "$(rsync_real_prefix)$REAL_FILES_DIR/"
	(
		real_dump
		self_content
		cat <<- EOF
			remove_backup_files_dir_if_empty
		EOF
	) | real_bash
}

rsync_root() {
	echo "$(prefix ">>>") $(alert "merging packages into real system ($REAL_ROOT, backup: $REAL_BACKUP_ROOT)")"
	(
		real_dump
		self_content
		cat <<- EOF
			create_backup_root
		EOF
	) | real_bash

	$REMOTE_RSYNC --backup-dir="$REAL_BACKUP_ROOT" --backup -av "$FAKE_ROOT/" "$(rsync_real_prefix)$REAL_ROOT/"

	echo "$(prefix ">>>") $(alert "searching for broken links")"
	(
		real_dump
		self_content
		cat <<- EOF
			remove_broken_links
			remove_backup_root_if_empty
		EOF
	) | real_bash
}

rsync_index() {
	$REMOTE_RSYNC -a "$FAKE_INDEX" "$(rsync_real_prefix)$REAL_INDEX"
}

create_backup_files_dir() {
	mkdir -p "$REAL_BACKUP_FILES_DIR"
}

remove_backup_files_dir_if_empty() {
	if [ $(ls -1A "$REAL_BACKUP_FILES_DIR" | wc -l) -eq 0 ]; then
		echo "removing empty backup directory $REAL_BACKUP_FILES_DIR"
		rmdir "$REAL_BACKUP_FILES_DIR"
	fi
}

create_backup_root() {
	mkdir -p "$REAL_BACKUP_ROOT"
}

remove_broken_links() {
	while IFS= read -r -d $'\0' file; do
		LINK_TARGET=$(readlink "$file")
		if [[ "x$LINK_TARGET" != "x${LINK_TARGET#$REAL_FILES_DIR/}" ]]; then
			mkdir -p "$(dirname "$REAL_BACKUP_ROOT/${file#$REAL_ROOT/}")"
			mv -vnT "$file" "$REAL_BACKUP_ROOT/${file#$REAL_ROOT/}"
			rmdir -p "$(dirname "$file")" 2>/dev/null || true
		fi
	done < <(
		if [ -r "$REAL_INDEX" ]; then
			xargs -0 -I'{}' -a "$REAL_INDEX" find -L '{}' -type l -print0 2>/dev/null
		else
			find -L "$REAL_ROOT" -type l -print0 2>/dev/null
		fi
	)
}

remove_backup_root_if_empty() {
	if [ $(ls -1A "$REAL_BACKUP_ROOT" | wc -l) -eq 0 ]; then
		echo "removing empty backup directory $REAL_BACKUP_ROOT"
		rmdir "$REAL_BACKUP_ROOT"
	fi
}
